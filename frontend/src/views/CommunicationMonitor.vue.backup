<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import MapStatsPanel from '../components/MapStatsPanel.vue'
import OnlineCitiesList from '../components/OnlineCitiesList.vue'
import MessageStreamList from '../components/MessageStreamList.vue'
import MapManager from '../services/mapManager.service'
import MessageAnimator from '../services/messageAnimation.service'
import useMonitorWebSocket from '../composables/useMonitorWebSocket'
import useTopology from '../composables/useTopology'
import apiService from '../services/api.service'

// UI çŠ¶æ€
const mapEl = ref(null)
const selectedCity = ref(null)
const isAnimationPaused = ref(false)
const filterType = ref('all') // 'all', 'encrypted', 'normal'
const isLoading = ref(false)
const errorMsg = ref('')

// æ•°æ®çŠ¶æ€
const onlineCities = ref([])
const recentMessages = ref([])
const statistics = ref({
  totalMessages: 0,
  encryptedMessages: 0,
  normalMessages: 0,
  onlineCitiesCount: 0,
  totalCitiesCount: 0
})
const statAnimationTrigger = ref(0)

// æœåŠ¡å®ä¾‹
let mapManager = null
let messageAnimator = null
let refreshTimer = null
let isComponentMounted = false

// ä½¿ç”¨ç»„åˆå¼å‡½æ•°
const { cities, edges, loadTopology } = useTopology()
const { wsStatus, connect: connectWebSocket, disconnect: disconnectWebSocket, manualReconnect } = useMonitorWebSocket({
  onMessage: handleWebSocketMessage,
  onConnected: () => {
    errorMsg.value = ''
  },
  onError: (error) => {
    errorMsg.value = error
  }
})

// åŠ è½½é«˜å¾·åœ°å›¾JS
function loadAmapJs() {
  return new Promise((resolve, reject) => {
    // å¦‚æœå·²ç»åŠ è½½ï¼Œç›´æ¥è¿”å›
    if (window.AMap) {
      console.log('âœ… é«˜å¾·åœ°å›¾ API å·²åŠ è½½')
      return resolve()
    }
    
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
    if (document.querySelector('script[src*="webapi.amap.com"]')) {
      console.log('â³ é«˜å¾·åœ°å›¾ API æ­£åœ¨åŠ è½½ä¸­ï¼Œç­‰å¾…å®Œæˆ...')
      // ç­‰å¾…åŠ è½½å®Œæˆ
      const checkInterval = setInterval(() => {
        if (window.AMap) {
          clearInterval(checkInterval)
          console.log('âœ… é«˜å¾·åœ°å›¾ API åŠ è½½å®Œæˆ')
          resolve()
        }
      }, 100)
      
      // è¶…æ—¶å¤„ç†
      setTimeout(() => {
        clearInterval(checkInterval)
        if (!window.AMap) {
          reject(new Error('é«˜å¾·åœ°å›¾åŠ è½½è¶…æ—¶'))
        }
      }, 10000)
      return
    }
    
    console.log('ğŸ“¥ å¼€å§‹åŠ è½½é«˜å¾·åœ°å›¾ API...')
    const script = document.createElement('script')
    script.src = `https://webapi.amap.com/maps?v=1.4.15&key=${AMAP_KEY}&plugin=AMap.Scale,AMap.ToolBar`
    script.async = true
    script.onload = () => {
      console.log('âœ… é«˜å¾·åœ°å›¾ API åŠ è½½æˆåŠŸ')
      resolve()
    }
    script.onerror = (e) => {
      console.error('âŒ é«˜å¾·åœ°å›¾ API åŠ è½½å¤±è´¥:', e)
      reject(new Error('é«˜å¾·åœ°å›¾ API åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'))
    }
    document.head.appendChild(script)
  })
}

// æ£€æŸ¥åç«¯å¥åº·çŠ¶æ€
async function checkBackendHealth() {
  try {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 3000)
    
    const response = await fetch('http://localhost:8001/health', {
      signal: controller.signal
    })
    
    clearTimeout(timeoutId)
    
    if (response.ok) {
      console.log('âœ… åç«¯æœåŠ¡æ­£å¸¸')
      return true
    } else {
      console.warn('âš ï¸ åç«¯æœåŠ¡å“åº”å¼‚å¸¸:', response.status)
      return false
    }
  } catch (error) {
    console.error('âŒ åç«¯æœåŠ¡ä¸å¯è®¿é—®:', error)
    return false
  }
}

// åŠ è½½åœ°å›¾
async function initMap() {
  try {
    isLoading.value = true
    errorMsg.value = ''
    
    // æ£€æŸ¥åç«¯æ˜¯å¦å¯è®¿é—®
    const backendHealthy = await checkBackendHealth()
    if (!backendHealthy) {
      errorMsg.value = 'åç«¯æœåŠ¡ä¸å¯è®¿é—®ï¼Œè¯·ç¡®ä¿åç«¯æœåŠ¡å·²å¯åŠ¨ï¼ˆhttp://localhost:8001ï¼‰'
      console.warn('âš ï¸ åç«¯æœåŠ¡ä¸å¯è®¿é—®ï¼Œå°†ç»§ç»­åŠ è½½åœ°å›¾ä½†åŠŸèƒ½å¯èƒ½å—é™')
    }
    
    console.log('ğŸ—ºï¸ å¼€å§‹åŠ è½½é«˜å¾·åœ°å›¾...')
    await loadAmapJs()
    
    if (!mapEl.value) {
      console.error('âŒ åœ°å›¾å®¹å™¨æœªæ‰¾åˆ°')
      errorMsg.value = 'åœ°å›¾å®¹å™¨æœªæ‰¾åˆ°'
      isLoading.value = false
      return
    }

    // ç­‰å¾…DOMå‡†å¤‡å¥½
    await new Promise(resolve => setTimeout(resolve, 300))

    console.log('ğŸ—ºï¸ åˆå§‹åŒ–åœ°å›¾å®ä¾‹...')
    mapInstance.value = new window.AMap.Map(mapEl.value, {
      zoom: 5,
      center: [108.5525, 34.3227],
      viewMode: '2D',
      mapStyle: 'amap://styles/blue'
    })

    console.log('âœ… åœ°å›¾åˆå§‹åŒ–æˆåŠŸ')

    // ç­‰å¾…å¹¶å°è¯•åŠ è½½æ‹“æ‰‘æ•°æ®ï¼ˆç»™æ‹“æ‰‘åŠ è½½ä¸€ä¸ªæœ€å¤§ç­‰å¾…æ—¶é—´ï¼Œé¿å…é•¿æ—¶é—´é˜»å¡ï¼‰
    const TOPOLOGY_TIMEOUT_MS = 5000
    let topologyLoaded = false
    try {
      await Promise.race([
        loadTopologyData(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('æ‹“æ‰‘åŠ è½½è¶…æ—¶')), TOPOLOGY_TIMEOUT_MS))
      ])
      topologyLoaded = true
      console.log('ğŸ“¡ æ‹“æ‰‘æ•°æ®åŠ è½½å®Œæˆ')
    } catch (err) {
      // è¶…æ—¶æˆ–å¤±è´¥çš„æƒ…å†µï¼šä¿ç•™å·²ä» localStorage è¯»å–çš„æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¹¶æç¤ºæ—¥å¿—
      console.warn('âš ï¸ æ‹“æ‰‘æ•°æ®åŠ è½½å¤±è´¥æˆ–è¶…æ—¶:', err)
    }

    // æ ¹æ®æ˜¯å¦æœ‰åŸå¸‚æ•°æ®æ¥å†³å®šåç»­æ¸²æŸ“
    if (cities.value.length > 0) {
      console.log('ğŸ¨ å¼€å§‹ç»˜åˆ¶åŸå¸‚å’Œè¿æ¥...')
      drawCitiesAndMST()
    } else {
      console.warn('âš ï¸ æ²¡æœ‰åŸå¸‚æ•°æ®ï¼Œè¯·å…ˆè®¿é—®"åŸå¸‚åœ°å›¾"é¡µé¢')
      errorMsg.value = 'æ²¡æœ‰åŸå¸‚æ•°æ®ï¼Œè¯·å…ˆè®¿é—®"åŸå¸‚åœ°å›¾"é¡µé¢åŠ è½½æ•°æ®'
    }

    // æ›´æ–°ç»Ÿè®¡çš„æ‹“æ‰‘åŸå¸‚æ€»æ•°ï¼ˆç”¨äºåœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºï¼‰
    statistics.value.totalCitiesCount = cities.value.length

    // ç¡®ä¿åœ¨åœ°å›¾å’Œåˆæ¬¡æ‹“æ‰‘å°è¯•å®Œæˆåå†éšè—åŠ è½½é®ç½©
    isLoading.value = false

    // å¯åŠ¨ç›‘æ§ï¼ˆåœ¨æ‹“æ‰‘å°è¯•åå¯åŠ¨ï¼Œä»¥å‡å°‘ç«æ€æƒ…å†µï¼‰
    startMonitoring()
    
  } catch (error) {
    console.error('âŒ åœ°å›¾åŠ è½½å¤±è´¥:', error)
    errorMsg.value = `åœ°å›¾åŠ è½½å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`
    isLoading.value = false
  }
}

// åŠ è½½æ‹“æ‰‘æ•°æ®
async function loadTopologyData() {
  // å…ˆå°è¯•ä» localStorage åŠ è½½åŸå¸‚æ•°æ®
  const citiesData = localStorage.getItem('cities')
  
  if (citiesData) {
    try {
      cities.value = JSON.parse(citiesData)
      console.log('âœ… ä» localStorage åŠ è½½åŸå¸‚æ•°æ®:', cities.value.length, 'ä¸ªåŸå¸‚')
    } catch (e) {
      console.error('è§£æ localStorage åŸå¸‚æ•°æ®å¤±è´¥:', e)
      cities.value = []
    }
  } else {
    console.warn('âš ï¸ localStorage ä¸­æ²¡æœ‰åŸå¸‚æ•°æ®')
  }

  // ä»åç«¯è·å–æ‹“æ‰‘çŠ¶æ€ï¼ˆåŒ…æ‹¬ MST è¾¹ï¼‰- ä½¿ç”¨è¶…æ—¶æ§åˆ¶
  try {
    console.log('ğŸ“¡ æ­£åœ¨è·å–åç«¯æ‹“æ‰‘çŠ¶æ€...')
    
    // åˆ›å»ºä¸€ä¸ªå¸¦è¶…æ—¶çš„ fetch è¯·æ±‚ï¼ˆ3ç§’è¶…æ—¶ï¼‰
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 3000)
    
    const response = await fetch('http://localhost:8001/topology/status', {
      signal: controller.signal
    })
    
    clearTimeout(timeoutId)
    
    if (response.ok) {
      const data = await response.json()
      console.log('ğŸ“¡ æ‹“æ‰‘çŠ¶æ€:', data)
      
      // ========== å…³é”®ä¿®å¤ï¼šæ€»æ˜¯ç¡®ä¿åç«¯æœ‰æ‹“æ‰‘æ•°æ® ==========
      // æ£€æŸ¥åç«¯æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ‹“æ‰‘æ•°æ®
      const backendHasTopology = data.cities > 0 && data.mst_edges_count > 0
      
      if (!backendHasTopology) {
        console.warn('âš ï¸ åç«¯æ²¡æœ‰æ‹“æ‰‘æ•°æ®ï¼Œå°è¯•ä»æœ¬åœ°åŠ è½½å¹¶å‘é€')
        // å°è¯•ä» localStorage åŠ è½½å¹¶å‘é€åˆ°åç«¯
        const localEdgesText = localStorage.getItem('edges')
        if (cities.value.length > 0 && localEdgesText) {
          try {
            const localEdges = JSON.parse(localEdgesText)
            if (Array.isArray(localEdges) && localEdges.length > 0) {
              console.log(`ğŸ“¤ å‘é€æœ¬åœ°æ‹“æ‰‘åˆ°åç«¯: ${cities.value.length} åŸå¸‚, ${localEdges.length} è¾¹`)
              const postResp = await fetch('http://localhost:8001/topology', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ cities: cities.value, edges: localEdges })
              })
              
              if (postResp.ok) {
                const postData = await postResp.json()
                console.log('âœ… æ‹“æ‰‘æ•°æ®å·²å‘é€åˆ°åç«¯:', postData)
                
                // é‡æ–°è·å–æ‹“æ‰‘çŠ¶æ€
                const resp2 = await fetch('http://localhost:8001/topology/status')
                if (resp2.ok) {
                  const data2 = await resp2.json()
                  if (data2.mst_edges && Array.isArray(data2.mst_edges) && data2.mst_edges.length > 0) {
                    edges.value = data2.mst_edges
                    console.log(`âœ… åç«¯è¿”å› MST è¾¹: ${edges.value.length} æ¡`)
                  }
                }
              } else {
                console.error('âŒ å‘é€æ‹“æ‰‘åˆ°åç«¯å¤±è´¥:', postResp.status)
              }
            }
          } catch (e) {
            console.error('âŒ å¤„ç†æœ¬åœ°æ‹“æ‰‘æ•°æ®å¤±è´¥:', e)
          }
        } else {
          console.warn('âš ï¸ æœ¬åœ°ä¹Ÿæ²¡æœ‰æ‹“æ‰‘æ•°æ®ï¼Œè¯·å…ˆè®¿é—®"åŸå¸‚åœ°å›¾"é¡µé¢åŠ è½½æ•°æ®')
        }
      } else {
        // åç«¯æœ‰æ‹“æ‰‘æ•°æ®ï¼Œç›´æ¥ä½¿ç”¨
        console.log('âœ… åç«¯å·²æœ‰æ‹“æ‰‘æ•°æ®')
      }
      
      // ========== åŠ è½½ MST è¾¹æ•°æ® ==========
      // å¦‚æœ localStorage ä¸­æ²¡æœ‰åŸå¸‚æ•°æ®ï¼Œä¸”åç«¯æœ‰åŸå¸‚åç§°åˆ—è¡¨ï¼Œå¯ä»¥å°è¯•æ„å»ºåŸºæœ¬æ•°æ®
      if (cities.value.length === 0 && data.city_names && data.city_names.length > 0) {
        console.log('âš ï¸ å°è¯•ä»åç«¯åŸå¸‚åç§°æ„å»ºæ•°æ®ï¼Œä½†ç¼ºå°‘ç»çº¬åº¦ä¿¡æ¯')
        console.log('è¯·å…ˆè®¿é—®"åŸå¸‚åœ°å›¾"é¡µé¢åŠ è½½å®Œæ•´æ•°æ®')
      }
      
      // ä½¿ç”¨åç«¯è®¡ç®—çš„ MST è¾¹ï¼ˆåªæ˜¾ç¤ºæœ€å°ç”Ÿæˆæ ‘ï¼‰
      if (data.mst_edges && Array.isArray(data.mst_edges) && data.mst_edges.length > 0) {
        edges.value = data.mst_edges
        console.log('âœ… åŠ è½½ MST è¾¹:', edges.value.length, 'æ¡ï¼ˆæœ€å°ç”Ÿæˆæ ‘ï¼‰')
      } else {
        console.warn('âš ï¸ åç«¯æœªè¿”å› MST è¾¹æ•°æ®')
        console.log('ä¿ç•™ç°æœ‰è¾¹æ•°æ®:', edges.value.length, 'æ¡')
      }
    } else {
      console.warn('âš ï¸ è·å–æ‹“æ‰‘çŠ¶æ€å¤±è´¥ï¼ŒHTTP çŠ¶æ€:', response.status)
      // ä¸æ¸…ç©ºedgesï¼Œä¿ç•™ç°æœ‰æ•°æ®
      console.log('ä¿ç•™ç°æœ‰è¾¹æ•°æ®:', edges.value.length, 'æ¡')
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      console.warn('âš ï¸ è·å–æ‹“æ‰‘çŠ¶æ€è¶…æ—¶ï¼ˆ3ç§’ï¼‰ï¼Œä¿ç•™ç°æœ‰æ‹“æ‰‘æ•°æ®')
    } else {
      console.error('âŒ è·å–æ‹“æ‰‘çŠ¶æ€å¤±è´¥:', error)
    }
    // å³ä½¿åç«¯å¤±è´¥ï¼Œä¿ç•™ç°æœ‰çš„è¾¹æ•°æ®
    console.log('ä¿ç•™ç°æœ‰è¾¹æ•°æ®:', edges.value.length, 'æ¡')
  }
  // æ›´æ–°ç»Ÿè®¡çš„æ‹“æ‰‘åŸå¸‚æ€»æ•°ï¼ˆå¦‚æœå­˜åœ¨åŸå¸‚æ•°æ®ï¼‰
  statistics.value.totalCitiesCount = cities.value.length
  return true
}

// ç»˜åˆ¶åŸå¸‚å’ŒMSTè¿æ¥
function drawCitiesAndMST() {
  if (!mapInstance.value) {
    console.error('âŒ åœ°å›¾å®ä¾‹ä¸å­˜åœ¨ï¼Œæ— æ³•ç»˜åˆ¶')
    return
  }
  
  if (!window.AMap) {
    console.error('âŒ AMap API æœªåŠ è½½ï¼Œæ— æ³•ç»˜åˆ¶')
    return
  }
  
  if (cities.value.length === 0) {
    console.warn('âš ï¸ æ²¡æœ‰åŸå¸‚æ•°æ®ï¼Œè·³è¿‡ç»˜åˆ¶')
    return
  }

  console.log(`ğŸ¨ å¼€å§‹ç»˜åˆ¶ ${cities.value.length} ä¸ªåŸå¸‚...`)
  
  // ç»˜åˆ¶åŸå¸‚èŠ‚ç‚¹
  cities.value.forEach(city => {
    try {
      const marker = new window.AMap.Marker({
        position: new window.AMap.LngLat(Number(city.lng), Number(city.lat)),
        title: city.name,
        content: createCityMarkerContent(city.name, false)
        // ä¸ä½¿ç”¨ offsetï¼Œè®© CSS transform æ¥å¤„ç†å®šä½
      })

      marker.on('click', () => {
        selectedCity.value = city
        showCityInfo(city)
      })

      marker.setMap(mapInstance.value)
      cityMarkers.value[city.name] = marker
    } catch (e) {
      console.error(`âŒ ç»˜åˆ¶åŸå¸‚ ${city.name} å¤±è´¥:`, e)
    }
  })
  
  console.log(`âœ… æˆåŠŸç»˜åˆ¶ ${Object.keys(cityMarkers.value).length} ä¸ªåŸå¸‚æ ‡è®°`)

  // ç»˜åˆ¶MSTè¿çº¿
  drawMSTLines()
}

// åˆ›å»ºåŸå¸‚æ ‡è®°å†…å®¹
function createCityMarkerContent(cityName, isOnline) {
  const color = isOnline ? '#22c55e' : '#94a3b8'
  const pulseClass = isOnline ? 'pulse-marker' : ''
  return `
    <div style="
      display: flex;
      flex-direction: column;
      align-items: center;
      transform: translate(-50%, -100%);
    ">
      <div class="${pulseClass}" style="
        width: 16px;
        height: 16px;
        background: ${color};
        border: 2px solid white;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        margin-bottom: 4px;
      "></div>
      <div style="
        background: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 11px;
        font-weight: 600;
        color: #334155;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        white-space: nowrap;
      ">${cityName}</div>
    </div>
  `
}

// ç»˜åˆ¶MSTè¿çº¿
function drawMSTLines() {
  console.log('ğŸ”µ drawMSTLines è¢«è°ƒç”¨', {
    edgesæ•°é‡: edges.value?.length || 0,
    citiesæ•°é‡: cities.value?.length || 0,
    hasAMap: !!window.AMap,
    hasMapInstance: !!mapInstance.value
  })

  if (!window.AMap || !mapInstance.value) {
    console.warn('âš ï¸ åœ°å›¾æœªåˆå§‹åŒ–ï¼Œè·³è¿‡ç»˜åˆ¶')
    return
  }

  if (!edges.value || edges.value.length === 0) {
    console.warn('âš ï¸ æ²¡æœ‰è¾¹æ•°æ®ï¼Œè·³è¿‡ç»˜åˆ¶')
    return
  }

  console.log(`ğŸ¨ å¼€å§‹ç»˜åˆ¶ ${edges.value.length} æ¡ MST è¾¹`)

  // æ¸…é™¤æ—§çš„MSTçº¿æ¡ï¼ˆåªåœ¨æœ‰æ–°çº¿æ¡è¦ç»˜åˆ¶æ—¶æ‰æ¸…é™¤ï¼‰
  if (mstLines.value && mstLines.value.length > 0) {
    console.log(`ğŸ§¹ æ¸…é™¤æ—§çš„ ${mstLines.value.length} æ¡çº¿æ¡`)
    mstLines.value.forEach(line => {
      if (line && line.setMap) {
        try {
          line.setMap(null)
        } catch (e) {
          console.warn('æ¸…é™¤çº¿æ¡å¤±è´¥:', e)
        }
      }
    })
  }
  mstLines.value = []

  // ç»˜åˆ¶æ–°çº¿æ¡
  let successCount = 0
  edges.value.forEach((edge, index) => {
    const city1 = cities.value[edge.u]
    const city2 = cities.value[edge.v]
    
    if (!city1 || !city2) {
      console.warn(`âš ï¸ è¾¹ ${index} çš„åŸå¸‚ç´¢å¼•æ— æ•ˆ: u=${edge.u}, v=${edge.v}`)
      return
    }

    if (!city1.lng || !city1.lat || !city2.lng || !city2.lat) {
      console.warn(`âš ï¸ åŸå¸‚åæ ‡ç¼ºå¤±: ${city1.name}(${city1.lng},${city1.lat}) -> ${city2.name}(${city2.lng},${city2.lat})`)
      return
    }

    try {
      const line = new window.AMap.Polyline({
        path: [
          new window.AMap.LngLat(Number(city1.lng), Number(city1.lat)),
          new window.AMap.LngLat(Number(city2.lng), Number(city2.lat))
        ],
        strokeColor: '#0ea5e9',
        strokeWeight: 2,
        strokeOpacity: 0.6,
        strokeStyle: 'solid',
        zIndex: 10
      })
      
      line.setMap(mapInstance.value)
      mstLines.value.push(line)
      successCount++
    } catch (e) {
      console.error(`âŒ ç»˜åˆ¶ ${city1.name} -> ${city2.name} è¿çº¿å¤±è´¥:`, e)
    }
  })
  
  console.log(`âœ… æˆåŠŸç»˜åˆ¶ ${successCount}/${edges.value.length} æ¡ MST çº¿æ¡ï¼Œæ€»è®¡ ${mstLines.value.length} æ¡çº¿åœ¨åœ°å›¾ä¸Š`)
}

// æ˜¾ç¤ºåŸå¸‚ä¿¡æ¯
function showCityInfo(city) {
  console.log('é€‰ä¸­åŸå¸‚:', city)
}

// å¼€å§‹ç›‘æ§
function startMonitoring() {
  // ç«‹å³åˆ·æ–°ä¸€æ¬¡åœ¨çº¿åŸå¸‚
  refreshOnlineCities()
  
  // å®šæ—¶åˆ·æ–°åœ¨çº¿åŸå¸‚ï¼ˆå¢åŠ é—´éš”åˆ°3ç§’ï¼Œå‡å°‘è¯·æ±‚é¢‘ç‡ï¼‰
  refreshTimer = setInterval(async () => {
    await refreshOnlineCities()
  }, 3000)

  // å»¶è¿Ÿå»ºç«‹ WebSocket ç›‘å¬ï¼ˆç­‰å¾…åœ°å›¾å’Œæ•°æ®åŠ è½½å®Œæˆï¼Œé¿å…é˜»å¡ï¼‰
  setTimeout(() => {
    if (isComponentMounted) {
      connectMonitorWebSocket()
    }
  }, 500)
}

function updateOnlineCities(nextCities) {
  const normalized = Array.from(new Set(
    (nextCities || [])
      .map(name => (typeof name === 'string' ? name.trim() : ''))
      .filter(name => name && name !== 'Monitor_Admin')
  ))

  onlineCities.value = normalized
  statistics.value.onlineCitiesCount = normalized.length
  updateCityMarkers()
}

// åˆ·æ–°åœ¨çº¿åŸå¸‚
async function refreshOnlineCities() {
  try {
    // æ·»åŠ è¶…æ—¶æ§åˆ¶ï¼ˆ5ç§’ï¼‰
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 5000)
    
    const response = await fetch('http://localhost:8001/cities', {
      signal: controller.signal
    })
    
    clearTimeout(timeoutId)
    
    if (response.ok) {
      const data = await response.json()
  updateOnlineCities(data.cities || [])
    } else {
      console.warn('âš ï¸ åˆ·æ–°åœ¨çº¿åŸå¸‚å¤±è´¥ï¼ŒHTTPçŠ¶æ€:', response.status)
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      console.warn('âš ï¸ åˆ·æ–°åœ¨çº¿åŸå¸‚è¶…æ—¶ï¼ˆ5ç§’ï¼‰')
    } else {
      console.error('âŒ åˆ·æ–°åœ¨çº¿åŸå¸‚å¤±è´¥:', error)
    }
    // è¶…æ—¶æˆ–å¤±è´¥ä¸æ¸…ç©ºç°æœ‰æ•°æ®ï¼Œé¿å…ç•Œé¢é—ªçƒ
  }
}

// æ›´æ–°åŸå¸‚æ ‡è®°çŠ¶æ€
function updateCityMarkers() {
  cities.value.forEach(city => {
    const marker = cityMarkers.value[city.name]
    if (marker) {
      const isOnline = onlineCities.value.includes(city.name)
      marker.setContent(createCityMarkerContent(city.name, isOnline))
    }
  })
}

// è¿æ¥ç›‘æ§ WebSocketï¼ˆç®¡ç†å‘˜ç›‘å¬æ‰€æœ‰æ¶ˆæ¯ï¼‰
function connectMonitorWebSocket() {
  // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œä¸è¦è¿æ¥
  if (!isComponentMounted) {
    console.log('[ç›‘æ§] ç»„ä»¶æœªæŒ‚è½½ï¼Œè·³è¿‡ WebSocket è¿æ¥')
    return
  }

  // æ¸…ç†ç°æœ‰è¿æ¥
  if (monitorWs) {
    monitorWs.onclose = null  // ç§»é™¤å…³é—­å¤„ç†å™¨ï¼Œé¿å…è§¦å‘é‡è¿
    monitorWs.onerror = null
    monitorWs.onmessage = null
    if (monitorWs.readyState === WebSocket.OPEN || monitorWs.readyState === WebSocket.CONNECTING) {
      monitorWs.close()
    }
    monitorWs = null
  }

  // æ¸…ç†é‡è¿å®šæ—¶å™¨
  if (reconnectTimer) {
    clearTimeout(reconnectTimer)
    reconnectTimer = null
  }

  try {
    const wsUrl = `ws://localhost:8001/ws/Monitor_Admin`
    console.log('[ç›‘æ§] å°è¯•è¿æ¥ WebSocket:', wsUrl)
    wsStatus.value = 'connecting'
    monitorWs = new WebSocket(wsUrl)
    
    monitorWs.onopen = () => {
      console.log('âœ… [ç›‘æ§] WebSocket è¿æ¥æˆåŠŸå»ºç«‹')
      reconnectAttempts = 0  // é‡ç½®é‡è¿æ¬¡æ•°
      errorMsg.value = ''  // æ¸…é™¤é”™è¯¯æ¶ˆæ¯
      wsStatus.value = 'connected'
    }
    
    monitorWs.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data)
        console.log('[ç›‘æ§] æ”¶åˆ°æ¶ˆæ¯:', data)
        
        // å¤„ç†æ™®é€šæ¶ˆæ¯
        if (data.type === 'message') {
          console.log('[ç›‘æ§] å¤„ç†æ™®é€šæ¶ˆæ¯')
          const messageRecord = {
            from: data.from,
            to: 'å…¨ä½“',
            content: data.message,
            type: 'normal'
          }
          addMessageRecord(messageRecord)
        }
        // å¤„ç†åŠ å¯†æ¶ˆæ¯
        else if (data.type === 'encrypted_message') {
          console.log('[ç›‘æ§] å¤„ç†åŠ å¯†æ¶ˆæ¯:', data.from, 'â†’', data.to)
          const messageRecord = {
            from: data.from,
            to: data.to,
            content: data.original_message || 'åŠ å¯†æ¶ˆæ¯',
            type: 'encrypted'
          }
          addMessageRecord(messageRecord)
        }
        // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯
        else if (data.type === 'system') {
          console.log('[ç›‘æ§] ç³»ç»Ÿæ¶ˆæ¯:', data.message)
          handleSystemMessage(data.message)
        }
      } catch (error) {
        console.error('[ç›‘æ§] è§£ææ¶ˆæ¯å¤±è´¥:', error)
      }
    }
    
    monitorWs.onclose = (event) => {
      console.log('[ç›‘æ§] WebSocket è¿æ¥å·²å…³é—­, code:', event.code, 'reason:', event.reason)
      wsStatus.value = 'disconnected'
      
      // åªæœ‰åœ¨ç»„ä»¶ä»ç„¶æŒ‚è½½ä¸”æœªè¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°æ—¶æ‰é‡è¿
      if (isComponentMounted && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
        reconnectAttempts++
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 10000)  // æŒ‡æ•°é€€é¿ï¼Œæœ€å¤š10ç§’
        console.log(`[ç›‘æ§] å°†åœ¨ ${delay}ms åå°è¯•ç¬¬ ${reconnectAttempts} æ¬¡é‡è¿...`)
        
        reconnectTimer = setTimeout(() => {
          if (isComponentMounted) {
            connectMonitorWebSocket()
          }
        }, delay)
      } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        console.warn('[ç›‘æ§] âš ï¸ å·²è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿')
        errorMsg.value = 'WebSocket è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æœåŠ¡æ˜¯å¦è¿è¡Œ'
        wsStatus.value = 'error'
      }
    }
    
    monitorWs.onerror = (error) => {
      console.error('âŒ [ç›‘æ§] WebSocket é”™è¯¯:', error)
      wsStatus.value = 'error'
    }
  } catch (error) {
    console.error('âŒ [ç›‘æ§] åˆ›å»º WebSocket è¿æ¥å¤±è´¥:', error)
    errorMsg.value = 'WebSocket è¿æ¥åˆ›å»ºå¤±è´¥'
    wsStatus.value = 'error'
  }
}

// æ‰‹åŠ¨é‡è¿ WebSocket
function manualReconnect() {
  console.log('[ç›‘æ§] æ‰‹åŠ¨é‡è¿...')
  reconnectAttempts = 0  // é‡ç½®é‡è¿æ¬¡æ•°
  errorMsg.value = ''
  connectMonitorWebSocket()
}

function handleSystemMessage(message) {
  if (!message) return

  const joinMatch = message.match(/^(.+?) å·²åŠ å…¥åŸå¸‚é€šè®¯ç½‘ç»œ/)
  if (joinMatch) {
    const cityName = joinMatch[1].trim()
    if (cityName && cityName !== 'Monitor_Admin' && !onlineCities.value.includes(cityName)) {
      updateOnlineCities([...onlineCities.value, cityName])
    }
    return
  }

  const leaveMatch = message.match(/^(.+?) (?:å·²ç¦»å¼€åŸå¸‚é€šè®¯ç½‘ç»œ|æ–­å¼€è¿æ¥|é€€å‡ºåŸå¸‚é€šè®¯ç½‘ç»œ)/)
  if (leaveMatch) {
    const cityName = leaveMatch[1].trim()
    if (cityName) {
      updateOnlineCities(onlineCities.value.filter(name => name !== cityName))
    }
    return
  }
}

// æ·»åŠ æ¶ˆæ¯è®°å½•
function addMessageRecord(message) {
  console.log('[ç›‘æ§] æ·»åŠ æ¶ˆæ¯è®°å½•:', message)
  
  recentMessages.value.unshift({
    id: Date.now(),
    ...message,
    timestamp: new Date().toLocaleTimeString(),
    isNew: true  // æ ‡è®°ä¸ºæ–°æ¶ˆæ¯
  })

  // 0.5ç§’åç§»é™¤æ–°æ¶ˆæ¯æ ‡è®°
  setTimeout(() => {
    const msg = recentMessages.value.find(m => m.id === recentMessages.value[0].id)
    if (msg) {
      msg.isNew = false
    }
  }, 500)

  // åªä¿ç•™æœ€è¿‘50æ¡
  if (recentMessages.value.length > 50) {
    recentMessages.value = recentMessages.value.slice(0, 50)
  }

  // æ›´æ–°ç»Ÿè®¡ï¼ˆå¸¦åŠ¨ç”»è§¦å‘ï¼‰
  const oldTotal = statistics.value.totalMessages
  statistics.value.totalMessages++
  if (message.type === 'encrypted') {
    statistics.value.encryptedMessages++
  } else {
    statistics.value.normalMessages++
  }
  
  // è§¦å‘æ•°å­—å˜åŒ–åŠ¨ç”»
  triggerStatAnimation()

  // åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºæ¶ˆæ¯åŠ¨ç”»
  console.log('[ç›‘æ§] æ£€æŸ¥æ˜¯å¦æ˜¾ç¤ºåŠ¨ç”» - æš‚åœçŠ¶æ€:', isAnimationPaused.value, 'è¿‡æ»¤ç»“æœ:', shouldShowMessage(message))
  if (!isAnimationPaused.value && shouldShowMessage(message)) {
    console.log('[ç›‘æ§] è§¦å‘æ¶ˆæ¯åŠ¨ç”»')
    animateMessage(message)
  } else {
    console.log('[ç›‘æ§] åŠ¨ç”»è¢«è·³è¿‡')
  }
}

// åˆ¤æ–­æ˜¯å¦åº”è¯¥æ˜¾ç¤ºæ¶ˆæ¯
function shouldShowMessage(message) {
  if (filterType.value === 'all') return true
  if (filterType.value === 'encrypted') return message.type === 'encrypted'
  if (filterType.value === 'normal') return message.type === 'normal'
  return true
}

// æ¶ˆæ¯åŠ¨ç”»
function animateMessage(message) {
  if (!window.AMap || !mapInstance.value) {
    console.log('[åŠ¨ç”»] åœ°å›¾æœªå‡†å¤‡å¥½ï¼Œè·³è¿‡åŠ¨ç”»')
    return
  }
  
  const fromCity = cities.value.find(c => c.name === message.from)
  if (!fromCity) {
    console.log('[åŠ¨ç”»] æ‰¾ä¸åˆ°å‘é€åŸå¸‚:', message.from)
    return
  }

  // å¦‚æœæ˜¯å¹¿æ’­æ¶ˆæ¯ï¼ˆto: 'å…¨ä½“'ï¼‰ï¼Œå‘æ‰€æœ‰åœ¨çº¿åŸå¸‚å‘é€åŠ¨ç”»
  if (message.to === 'å…¨ä½“') {
    console.log('[åŠ¨ç”»] å¹¿æ’­æ¶ˆæ¯åŠ¨ç”»:', message.from, 'â†’ å…¨ä½“ï¼Œåœ¨çº¿åŸå¸‚æ•°:', onlineCities.value.length)
    const targetCities = onlineCities.value.filter(cityName => 
      cityName !== message.from && cityName !== 'Monitor_Admin'
    )
    console.log('[åŠ¨ç”»] ç›®æ ‡åŸå¸‚:', targetCities)
    
    targetCities.forEach(cityName => {
      const toCity = cities.value.find(c => c.name === cityName)
      if (toCity) {
        createMessageAnimation(fromCity, toCity, message.type)
      } else {
        console.log('[åŠ¨ç”»] åœ¨çº¿åŸå¸‚æ‰¾ä¸åˆ°åæ ‡:', cityName)
      }
    })
    return
  }

  // ç‚¹å¯¹ç‚¹æ¶ˆæ¯
  const toCity = cities.value.find(c => c.name === message.to)
  if (!toCity) {
    console.log('[åŠ¨ç”»] æ‰¾ä¸åˆ°æ¥æ”¶åŸå¸‚:', message.to)
    return
  }

  console.log('[åŠ¨ç”»] ç‚¹å¯¹ç‚¹æ¶ˆæ¯åŠ¨ç”»:', message.from, 'â†’', message.to)
  createMessageAnimation(fromCity, toCity, message.type)
}

// åˆ›å»ºå•ä¸ªæ¶ˆæ¯åŠ¨ç”»
function createMessageAnimation(fromCity, toCity, messageType) {
  if (!window.AMap || !mapInstance.value) return

  const color = messageType === 'encrypted' ? '#8b5cf6' : '#0ea5e9'
  const glowColor = messageType === 'encrypted' ? 'rgba(139, 92, 246, 0.4)' : 'rgba(14, 165, 233, 0.4)'
  
  // åˆ›å»ºåŠ¨æ€é—ªçƒçš„è·¯å¾„çº¿æ¡
  const messageLine = new window.AMap.Polyline({
    path: [
      new window.AMap.LngLat(Number(fromCity.lng), Number(fromCity.lat)),
      new window.AMap.LngLat(Number(toCity.lng), Number(toCity.lat))
    ],
    strokeColor: color,
    strokeWeight: 4,
    strokeOpacity: 0.8,
    strokeStyle: 'solid',
    zIndex: 100
  })
  
  messageLine.setMap(mapInstance.value)
  
  // åˆ›å»ºå‘å…‰èƒŒæ™¯çº¿æ¡
  const glowLine = new window.AMap.Polyline({
    path: [
      new window.AMap.LngLat(Number(fromCity.lng), Number(fromCity.lat)),
      new window.AMap.LngLat(Number(toCity.lng), Number(toCity.lat))
    ],
    strokeColor: color,
    strokeWeight: 12,
    strokeOpacity: 0.3,
    strokeStyle: 'solid',
    zIndex: 99
  })
  
  glowLine.setMap(mapInstance.value)
  
  // åˆ›å»ºå¤šä¸ªç²’å­æ•ˆæœï¼ˆ3ä¸ªç²’å­ï¼‰
  const particles = []
  const particleCount = 3
  const particleDelay = 150 // ç²’å­é—´éš”å»¶è¿Ÿ
  
  for (let i = 0; i < particleCount; i++) {
    setTimeout(() => {
      createParticle(fromCity, toCity, color, glowColor, i, particleCount)
    }, i * particleDelay)
  }
  
  // è·¯å¾„é—ªçƒåŠ¨ç”»
  let lineOpacity = 0.8
  let lineDirection = -1
  const lineInterval = setInterval(() => {
    lineOpacity += lineDirection * 0.1
    if (lineOpacity <= 0.3) {
      lineOpacity = 0.3
      lineDirection = 1
    } else if (lineOpacity >= 0.8) {
      lineOpacity = 0.8
      lineDirection = -1
    }
    if (messageLine && messageLine.setOptions) {
      messageLine.setOptions({ strokeOpacity: lineOpacity })
    }
  }, 100)
  
  // æ¸…ç†åŠ¨ç”»
  const duration = 2500
  setTimeout(() => {
    clearInterval(lineInterval)
    
    // æ·¡å‡ºæ•ˆæœ
    let fadeOpacity = 0.8
    const fadeInterval = setInterval(() => {
      fadeOpacity -= 0.1
      if (fadeOpacity <= 0) {
        clearInterval(fadeInterval)
        messageLine.setMap(null)
        glowLine.setMap(null)
      } else {
        messageLine.setOptions({ strokeOpacity: fadeOpacity })
        glowLine.setOptions({ strokeOpacity: fadeOpacity * 0.3 })
      }
    }, 50)
  }, duration)
}

// åˆ›å»ºå•ä¸ªç²’å­
function createParticle(fromCity, toCity, color, glowColor, index, total) {
  if (!window.AMap || !mapInstance.value) return
  
  const size = 14 - index * 2 // ç²’å­å¤§å°é€’å‡
  
  // åˆ›å»ºç²’å­æ ‡è®°
  const particleMarker = new window.AMap.Marker({
    position: new window.AMap.LngLat(Number(fromCity.lng), Number(fromCity.lat)),
    content: `
      <div class="message-particle" style="
        width: ${size}px;
        height: ${size}px;
        background: ${color};
        border: 2px solid white;
        border-radius: 50%;
        box-shadow: 0 0 20px ${glowColor}, 0 0 40px ${glowColor};
        position: relative;
      ">
        <div style="
          position: absolute;
          inset: -4px;
          border-radius: 50%;
          background: ${glowColor};
          filter: blur(6px);
          animation: particle-pulse 0.8s ease-in-out infinite;
          animation-delay: ${index * 0.15}s;
        "></div>
      </div>
    `,
    offset: new window.AMap.Pixel(-size/2, -size/2),
    zIndex: 102 - index
  })
  
  particleMarker.setMap(mapInstance.value)
  
  // åˆ›å»ºæ‹–å°¾æ•ˆæœæ ‡è®°
  const trailMarker = new window.AMap.Marker({
    position: new window.AMap.LngLat(Number(fromCity.lng), Number(fromCity.lat)),
    content: `
      <div style="
        width: ${size * 3}px;
        height: ${size}px;
        background: linear-gradient(90deg, transparent, ${glowColor}, transparent);
        border-radius: ${size}px;
        filter: blur(4px);
        opacity: 0.6;
      "></div>
    `,
    offset: new window.AMap.Pixel(-size * 1.5, -size/2),
    zIndex: 101 - index
  })
  
  trailMarker.setMap(mapInstance.value)
  
  // ç²’å­ç§»åŠ¨åŠ¨ç”»ï¼ˆä½¿ç”¨ easeInOutCubic ç¼“åŠ¨ï¼‰
  const duration = 2000
  const startTime = Date.now()
  
  function easeInOutCubic(t) {
    return t < 0.5 
      ? 4 * t * t * t 
      : 1 - Math.pow(-2 * t + 2, 3) / 2
  }
  
  function moveParticle() {
    const elapsed = Date.now() - startTime
    let progress = Math.min(elapsed / duration, 1)
    
    // åº”ç”¨ç¼“åŠ¨å‡½æ•°
    progress = easeInOutCubic(progress)
    
    // è®¡ç®—å½“å‰ä½ç½®
    const currentLng = fromCity.lng + (toCity.lng - fromCity.lng) * progress
    const currentLat = fromCity.lat + (toCity.lat - fromCity.lat) * progress
    
    particleMarker.setPosition(new window.AMap.LngLat(Number(currentLng), Number(currentLat)))
    
    // æ‹–å°¾ç¨å¾®æ»å
    const trailProgress = Math.max(0, progress - 0.05)
    const trailLng = fromCity.lng + (toCity.lng - fromCity.lng) * trailProgress
    const trailLat = fromCity.lat + (toCity.lat - fromCity.lat) * trailProgress
    trailMarker.setPosition(new window.AMap.LngLat(Number(trailLng), Number(trailLat)))
    
    if (progress < 1) {
      requestAnimationFrame(moveParticle)
    } else {
      // åˆ°è¾¾ç›®æ ‡ï¼Œæ·»åŠ çˆ†ç‚¸æ•ˆæœ
      createArrivalEffect(toCity, color, glowColor)
      
      // æ·¡å‡ºç²’å­
      setTimeout(() => {
        particleMarker.setMap(null)
        trailMarker.setMap(null)
      }, 300)
    }
  }
  
  moveParticle()
}

// åˆ›å»ºåˆ°è¾¾çˆ†ç‚¸æ•ˆæœ
function createArrivalEffect(city, color, glowColor) {
  if (!window.AMap || !mapInstance.value) return
  
  const effectMarker = new window.AMap.Marker({
    position: new window.AMap.LngLat(Number(city.lng), Number(city.lat)),
    content: `
      <div style="
        width: 40px;
        height: 40px;
        border: 3px solid ${color};
        border-radius: 50%;
        box-shadow: 0 0 30px ${glowColor};
        animation: arrival-burst 0.6s ease-out;
      "></div>
    `,
    offset: new window.AMap.Pixel(-20, -20),
    zIndex: 103
  })
  
  effectMarker.setMap(mapInstance.value)
  
  // ç§»é™¤æ•ˆæœ
  setTimeout(() => {
    effectMarker.setMap(null)
  }, 600)
}

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(timestamp) {
  return new Date(timestamp).toLocaleTimeString()
}

// è§¦å‘ç»Ÿè®¡åŠ¨ç”»
const statAnimationTrigger = ref(0)
function triggerStatAnimation() {
  statAnimationTrigger.value++
}

// æ¸…ç©ºæ¶ˆæ¯è®°å½•
function clearMessages() {
  recentMessages.value = []
  statistics.value = {
    totalMessages: 0,
    encryptedMessages: 0,
    normalMessages: 0,
    onlineCitiesCount: onlineCities.value.length,
    totalCitiesCount: cities.value.length
  }
}

// æ³¨é‡Šæ‰ watch ç›‘å¬å™¨ï¼Œæ”¹ä¸ºæ‰‹åŠ¨æ§åˆ¶é‡ç»˜æ—¶æœº
// é—®é¢˜ï¼šwatch çš„ deep:true ä¼šå¯¼è‡´é¢‘ç¹è§¦å‘ï¼Œè€Œä¸”å¯èƒ½åœ¨ä¸é€‚å½“çš„æ—¶å€™æ¸…ç©ºçº¿æ¡
// watch(edges, (newEdges, oldEdges) => {
//   console.log('ğŸ“Š edges å‘ç”Ÿå˜åŒ–:', {
//     æ—§è¾¹æ•°: oldEdges?.length || 0,
//     æ–°è¾¹æ•°: newEdges?.length || 0
//   })
//   
//   // åªæœ‰åœ¨åœ°å›¾å·²åˆå§‹åŒ–çš„æƒ…å†µä¸‹æ‰é‡ç»˜
//   if (mapInstance.value && newEdges && newEdges.length > 0) {
//     console.log('ğŸ”„ é‡æ–°ç»˜åˆ¶ MST çº¿æ¡...')
//     drawMSTLines()
//   }
// }, { deep: true })

// ç»„ä»¶æŒ‚è½½
onMounted(() => {
  isComponentMounted = true
  reconnectAttempts = 0
  initMap()
})

// ç»„ä»¶å¸è½½
onUnmounted(() => {
  console.log('[ç›‘æ§] ç»„ä»¶å¸è½½ï¼Œæ¸…ç†èµ„æº...')
  isComponentMounted = false  // æ ‡è®°ç»„ä»¶å·²å¸è½½
  
  // æ¸…ç†å®šæ—¶å™¨
  if (refreshTimer) {
    clearInterval(refreshTimer)
    refreshTimer = null
  }
  
  if (reconnectTimer) {
    clearTimeout(reconnectTimer)
    reconnectTimer = null
  }
  
  // æ¸…ç† WebSocket è¿æ¥
  if (monitorWs) {
    // å…ˆç§»é™¤äº‹ä»¶å¤„ç†å™¨ï¼Œé˜²æ­¢è§¦å‘é‡è¿
    monitorWs.onclose = null
    monitorWs.onerror = null
    monitorWs.onmessage = null
    monitorWs.onopen = null
    
    // å…³é—­è¿æ¥
    if (monitorWs.readyState === WebSocket.OPEN || monitorWs.readyState === WebSocket.CONNECTING) {
      monitorWs.close()
    }
    monitorWs = null
  }
  
  console.log('[ç›‘æ§] âœ… èµ„æºæ¸…ç†å®Œæˆ')
})
</script>

<template>
  <div class="monitor-page">
    <div class="monitor-header">
      <div class="header-left">
        <h2>ğŸŒ åŸå¸‚ç½‘ç»œé€šè®¯ç›‘æ§ä¸­å¿ƒ</h2>
        <div class="ws-status" :class="`status-${wsStatus}`">
          <span class="status-dot"></span>
          <span class="status-text">
            {{ wsStatus === 'connected' ? 'å·²è¿æ¥' : 
               wsStatus === 'connecting' ? 'è¿æ¥ä¸­...' : 
               wsStatus === 'error' ? 'è¿æ¥é”™è¯¯' : 'æœªè¿æ¥' }}
          </span>
          <button 
            v-if="wsStatus === 'error' || wsStatus === 'disconnected'" 
            @click="manualReconnect"
            class="reconnect-btn"
            title="é‡æ–°è¿æ¥"
          >
            ğŸ”„
          </button>
        </div>
      </div>
      <div class="header-controls">
        <button 
          class="control-btn"
          :class="{ active: !isAnimationPaused }"
          @click="isAnimationPaused = !isAnimationPaused"
        >
          {{ isAnimationPaused ? 'â–¶ ç»§ç»­' : 'â¸ æš‚åœ' }}
        </button>
        <select v-model="filterType" class="filter-select">
          <option value="all">å…¨éƒ¨æ¶ˆæ¯</option>
          <option value="encrypted">ç«¯åˆ°ç«¯é€šè®¯</option>
          <option value="normal">å¹¿æ’­æ¶ˆæ¯</option>
        </select>
      </div>
    </div>

    <div class="monitor-content">
      <!-- å·¦ä¾§åœ°å›¾åŒºåŸŸ -->
      <div class="map-section">
        <div v-if="isLoading" class="loading-overlay">
          <div class="loading-spinner"></div>
          <p>åœ°å›¾åŠ è½½ä¸­...</p>
        </div>
        <div v-if="errorMsg && !isLoading" class="error-overlay">
          <div style="text-align: center;">
            <p style="color: #dc2626; font-weight: 600; margin-bottom: 8px;">âš ï¸ {{ errorMsg }}</p>
            <button 
              @click="initMap" 
              style="padding: 8px 16px; background: #0ea5e9; color: white; border: none; border-radius: 6px; cursor: pointer; margin-top: 12px;"
            >
              ğŸ”„ é‡æ–°åŠ è½½
            </button>
          </div>
        </div>
        <div ref="mapEl" class="map-container"></div>
        
        <!-- åœ°å›¾ä¸Šçš„ç»Ÿè®¡é¢æ¿ -->
        <div class="map-overlay-stats">
          <div class="stat-card">
            <div class="stat-value" :key="`online-${statistics.onlineCitiesCount}`">
              {{ statistics.onlineCitiesCount }}
            </div>
            <div class="stat-label">åœ¨çº¿åŸå¸‚</div>
          </div>
          <div class="stat-card" :class="{ 'stat-pulse': statAnimationTrigger > 0 }">
            <div class="stat-value" :key="`total-${statistics.totalMessages}`">
              {{ statistics.totalMessages }}
            </div>
            <div class="stat-label">æ€»æ¶ˆæ¯æ•°</div>
          </div>
          <div class="stat-card encrypted" :class="{ 'stat-pulse': statAnimationTrigger > 0 }">
            <div class="stat-value" :key="`encrypted-${statistics.encryptedMessages}`">
              {{ statistics.encryptedMessages }}
            </div>
            <div class="stat-label">ç«¯åˆ°ç«¯é€šè®¯</div>
          </div>
        </div>
      </div>

      <!-- å³ä¾§ä¿¡æ¯é¢æ¿ -->
      <aside class="info-panel">
        <!-- åœ¨çº¿åŸå¸‚åˆ—è¡¨ -->
        <div class="panel-section">
          <h3>ğŸ“ åœ¨çº¿åŸå¸‚ ({{ onlineCities.length }})</h3>
          <div class="online-cities-list">
            <div 
              v-for="city in onlineCities" 
              :key="city"
              class="online-city-item"
              :class="{ selected: selectedCity?.name === city }"
              @click="selectedCity = cities.find(c => c.name === city)"
            >
              <span class="online-dot"></span>
              {{ city }}
            </div>
            <div v-if="!onlineCities.length" class="empty-state">
              æš‚æ— åœ¨çº¿åŸå¸‚
            </div>
          </div>
        </div>

        <!-- å®æ—¶æ¶ˆæ¯æµ -->
        <div class="panel-section messages-section">
          <div class="section-header">
            <h3>ğŸ’¬ å®æ—¶æ¶ˆæ¯æµ</h3>
            <button @click="clearMessages" class="clear-btn">æ¸…ç©º</button>
          </div>
          <div class="messages-list">
            <transition-group name="message-list">
              <div 
                v-for="msg in recentMessages" 
                :key="msg.id"
                class="message-item"
                :class="{ 
                  encrypted: msg.type === 'encrypted',
                  'new-message': msg.isNew
                }"
              >
                <div class="message-header">
                  <span class="message-type">
                    {{ msg.type === 'encrypted' ? 'ğŸ”' : 'ğŸ“¨' }}
                  </span>
                  <span class="message-route">{{ msg.from }} â†’ {{ msg.to }}</span>
                  <span class="message-time">{{ msg.timestamp }}</span>
                </div>
                <div class="message-content">{{ msg.content }}</div>
                <div v-if="msg.isNew" class="new-indicator"></div>
              </div>
            </transition-group>
            <div v-if="!recentMessages.length" class="empty-state">
              æš‚æ— æ¶ˆæ¯è®°å½•
            </div>
          </div>
        </div>
      </aside>
    </div>
  </div>
</template>

<style scoped>
.monitor-page {
  min-height: calc(100vh - 60px);
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding-bottom: 20px;
}

.monitor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  background: white;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.monitor-header h2 {
  margin: 0;
  font-size: 24px;
  color: #1e293b;
}

.ws-status {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.ws-status.status-connected {
  background: #dcfce7;
  color: #15803d;
}

.ws-status.status-connecting {
  background: #fef3c7;
  color: #92400e;
}

.ws-status.status-disconnected {
  background: #f1f5f9;
  color: #64748b;
}

.ws-status.status-error {
  background: #fee2e2;
  color: #dc2626;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  transition: all 0.3s ease;
}

.status-connected .status-dot {
  background: #22c55e;
  animation: pulse-status 2s ease-in-out infinite;
}

.status-connecting .status-dot {
  background: #f59e0b;
  animation: blink-status 1s ease-in-out infinite;
}

.status-disconnected .status-dot {
  background: #94a3b8;
}

.status-error .status-dot {
  background: #ef4444;
  animation: shake-status 0.5s ease-in-out infinite;
}

.reconnect-btn {
  padding: 2px 6px;
  background: transparent;
  border: none;
  cursor: pointer;
  font-size: 14px;
  transition: transform 0.2s ease;
}

.reconnect-btn:hover {
  transform: scale(1.2) rotate(90deg);
}

.reconnect-btn:active {
  transform: scale(0.9) rotate(180deg);
}

.header-controls {
  display: flex;
  gap: 12px;
}

.control-btn {
  padding: 8px 16px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  background: white;
  color: #64748b;
  cursor: pointer;
  transition: all 0.2s;
  font-weight: 500;
}

.control-btn:hover {
  background: #f1f5f9;
  border-color: #0ea5e9;
}

.control-btn.active {
  background: #0ea5e9;
  color: white;
  border-color: #0ea5e9;
}

.filter-select {
  padding: 8px 12px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  background: white;
  color: #334155;
  cursor: pointer;
  font-size: 14px;
}

.monitor-content {
  display: grid;
  grid-template-columns: 1fr 192px;
  gap: 20px;
  flex: 1;
  overflow: hidden;
}

.map-section {
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid #e5e7eb;
}

.map-container {
  width: 100%;
  height: 100%;
  min-height: calc(100vh - 180px);
}

.loading-overlay,
.error-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.95);
  z-index: 1000;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 4px solid #e2e8f0;
  border-top-color: #0ea5e9;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 16px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading-overlay p,
.error-overlay p {
  color: #64748b;
  font-size: 14px;
  margin: 0;
}

.error-overlay p {
  color: #dc2626;
}

.map-overlay-stats {
  position: absolute;
  top: 16px;
  left: 16px;
  display: flex;
  gap: 10px;
  pointer-events: none;
}

.stat-card {
  background: rgba(255, 255, 255, 0.95);
  padding: 12px 16px;
  border-radius: 10px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(10px);
  min-width: 90px;
  text-align: center;
  transition: all 0.3s ease;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
}

.stat-card.stat-pulse {
  animation: stat-card-pulse 0.6s ease-out;
}

.stat-card.encrypted {
  background: linear-gradient(135deg, rgba(139, 92, 246, 0.95) 0%, rgba(124, 58, 237, 0.95) 100%);
  color: white;
}

.stat-value {
  font-size: 24px;
  font-weight: 700;
  color: #0ea5e9;
  margin-bottom: 2px;
  transition: all 0.3s ease;
}

.stat-card .stat-value {
  animation: stat-number-pop 0.4s ease-out;
}

.stat-card.encrypted .stat-value {
  color: white;
}

.stat-label {
  font-size: 11px;
  color: #64748b;
  font-weight: 500;
}

.stat-card.encrypted .stat-label {
  color: rgba(255, 255, 255, 0.9);
}

.info-panel {
  display: flex;
  flex-direction: column;
  gap: 16px;
  overflow: hidden;
}

.panel-section {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 12px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.panel-section h3 {
  margin: 0 0 10px 0;
  font-size: 14px;
  color: #1e293b;
  font-weight: 600;
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.section-header h3 {
  margin: 0;
}

.clear-btn {
  padding: 4px 12px;
  font-size: 12px;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  background: white;
  color: #64748b;
  cursor: pointer;
  transition: all 0.2s;
}

.clear-btn:hover {
  background: #fee2e2;
  border-color: #fca5a5;
  color: #dc2626;
}

.online-cities-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: 180px;
  overflow-y: auto;
}

.online-city-item {
  padding: 6px 10px;
  background: #f0fdf4;
  border: 1px solid #bbf7d0;
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 13px;
  color: #15803d;
}

.online-city-item:hover {
  background: #dcfce7;
  transform: translateX(4px);
}

.online-city-item.selected {
  background: #22c55e;
  color: white;
  border-color: #16a34a;
}

.online-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #22c55e;
  animation: pulse 2s infinite;
}

.online-city-item.selected .online-dot {
  background: white;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.messages-section {
  flex: 1;
  min-height: 0;
}

.messages-list {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.message-item {
  padding: 10px;
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  border-left: 3px solid #0ea5e9;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.message-item:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  transform: translateX(2px);
}

.message-item.encrypted {
  background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
  border-left-color: #8b5cf6;
}

.message-item.new-message {
  animation: message-enter 0.5s ease-out;
  box-shadow: 0 4px 16px rgba(14, 165, 233, 0.3);
}

.message-item.encrypted.new-message {
  box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
}

.new-indicator {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, #0ea5e9, transparent);
  animation: indicator-slide 0.5s ease-out;
}

.message-item.encrypted .new-indicator {
  background: linear-gradient(90deg, transparent, #8b5cf6, transparent);
}

.message-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
  font-size: 12px;
}

.message-type {
  font-size: 14px;
}

.message-route {
  flex: 1;
  font-weight: 600;
  color: #334155;
}

.message-time {
  color: #94a3b8;
  font-size: 10px;
}

.message-content {
  font-size: 12px;
  color: #64748b;
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.empty-state {
  padding: 40px 20px;
  text-align: center;
  color: #94a3b8;
  font-size: 13px;
}

/* æ·»åŠ CSSåŠ¨ç”» */
@keyframes pulse-dot {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
  }
  50% {
    box-shadow: 0 0 0 6px rgba(34, 197, 94, 0);
  }
}

@keyframes pulse-message {
  0%, 100% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.3);
    opacity: 0.8;
  }
}

/* åœ¨çº¿åŸå¸‚æ ‡è®°è„‰å†²åŠ¨ç”» */
:global(.pulse-marker) {
  animation: pulse-marker 2s ease-in-out infinite;
}

@keyframes pulse-marker {
  0%, 100% {
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }
  50% {
    box-shadow: 0 0 0 8px rgba(34, 197, 94, 0.3), 0 2px 8px rgba(0,0,0,0.4);
  }
}

/* ç²’å­è„‰å†²åŠ¨ç”» */
:global(.message-particle) {
  animation: particle-float 0.8s ease-in-out infinite;
}

@keyframes particle-float {
  0%, 100% {
    transform: scale(1) translateY(0);
  }
  50% {
    transform: scale(1.15) translateY(-2px);
  }
}

/* ç²’å­å†…éƒ¨å‘å…‰åŠ¨ç”» */
@keyframes particle-pulse {
  0%, 100% {
    opacity: 0.6;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.5);
  }
}

/* åˆ°è¾¾çˆ†ç‚¸æ•ˆæœ */
@keyframes arrival-burst {
  0% {
    transform: scale(0.5);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.8;
  }
  100% {
    transform: scale(2);
    opacity: 0;
  }
}

/* æ¶ˆæ¯è¿›å…¥åŠ¨ç”» */
@keyframes message-enter {
  0% {
    opacity: 0;
    transform: translateX(-30px) scale(0.9);
  }
  50% {
    transform: translateX(5px) scale(1.02);
  }
  100% {
    opacity: 1;
    transform: translateX(0) scale(1);
  }
}

/* æ–°æ¶ˆæ¯æŒ‡ç¤ºå™¨åŠ¨ç”» */
@keyframes indicator-slide {
  0% {
    transform: translateX(-100%);
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateX(100%);
    opacity: 0;
  }
}

/* Vue è¿‡æ¸¡åŠ¨ç”» */
.message-list-enter-active {
  animation: message-enter 0.5s ease-out;
}

.message-list-leave-active {
  transition: all 0.3s ease;
}

.message-list-leave-to {
  opacity: 0;
  transform: translateX(30px);
}

.message-list-move {
  transition: transform 0.3s ease;
}

/* ç»Ÿè®¡å¡ç‰‡åŠ¨ç”» */
@keyframes stat-card-pulse {
  0%, 100% {
    transform: scale(1);
  }
  30% {
    transform: scale(1.08);
  }
  60% {
    transform: scale(0.98);
  }
}

@keyframes stat-number-pop {
  0% {
    transform: scale(1);
  }
  40% {
    transform: scale(1.3);
  }
  70% {
    transform: scale(0.95);
  }
  100% {
    transform: scale(1);
  }
}

/* WebSocket çŠ¶æ€åŠ¨ç”» */
@keyframes pulse-status {
  0%, 100% {
    opacity: 1;
    box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
  }
  50% {
    opacity: 0.7;
    box-shadow: 0 0 0 4px rgba(34, 197, 94, 0);
  }
}

@keyframes blink-status {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.3;
  }
}

@keyframes shake-status {
  0%, 100% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-2px);
  }
  75% {
    transform: translateX(2px);
  }
}

/* æ»šåŠ¨æ¡æ ·å¼ */
.online-cities-list::-webkit-scrollbar,
.messages-list::-webkit-scrollbar {
  width: 6px;
}

.online-cities-list::-webkit-scrollbar-track,
.messages-list::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 3px;
}

.online-cities-list::-webkit-scrollbar-thumb,
.messages-list::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.online-cities-list::-webkit-scrollbar-thumb:hover,
.messages-list::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}
</style>
